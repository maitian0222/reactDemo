{"version":3,"sources":["demo/immer/TestImmer.tsx","../node_modules/immer/dist/immer.module.js"],"names":["Object","defineProperty","__webpack_exports__","value","_a","__WEBPACK_IMPORTED_MODULE_0_react__","todo","done","todos","setTodos","map","item","index","key","onClick","__WEBPACK_IMPORTED_MODULE_1_immer__","draft","push","onBtnClick","__webpack_require__","n","window","produce","process","obj","NOTHING","Symbol","DRAFTABLE","for","DRAFT_STATE","isDraft","isDraftable","Array","isArray","proto","getPrototypeOf","prototype","constructor","assign","target","has","ownKeys","Reflect","getOwnPropertySymbols","getOwnPropertyNames","concat","shallowCopy","base","invokeGetters","slice","clone","create","forEach","desc","getOwnPropertyDescriptor","get","Error","call","enumerable","writable","configurable","each","cb","i","length","isEnumerable","prop","thing","hasOwnProperty","is","x","y","ImmerScope","parent","this","drafts","canAutoFreeze","patches","revoke","usePatches","patchListener","inversePatches","leave","current","enter","descriptors","createProxy","clonePotentialDraft","state","assertUnrevoked","peek","source","finalizing","prepareCopy","copy","set","assigned","modified","markChanged","proxyProperty","scope","createHiddenProperty","finalized","revoke$1","revoked","JSON","stringify","markChangesSweep","hasArrayChanges","hasObjectChanges","keys","baseValue","undefined","state$1","descriptor","legacyProxy","freeze","willFinalize","result","isReplaced","markChangesRecursively","object","i$1","i$2","createProxy$1","ref","Proxy","revocable","arrayTraps","objectTraps","proxy","source$1","peek$1","isUnchanged","markChanged$1","deleteProperty","owner","setPrototypeOf","fn","arguments","apply","isNaN","parseInt","modernProxy","generatePatches","basePath","assign$1","delta","start","end","path","op","useRemove","replaceCount","path$1","generateArrayPatches","assignedValue","origValue","generateObjectPatches","applyPatches","patch","join","splice","configDefaults","useProxies","autoFreeze","name","onAssign","onDelete","onCopy","Immer","config","setUseProxies","bind","recipe","this$1","defaultBase","self","args","len","hasError","Promise","then","processResult","error","createDraft","isManual","finishDraft","setAutoFreeze","baseDraft","finalize","isFrozen","finalizeTree","root","rootPath","needPatches","finalizeProperty","isDraftProp","immer"],"mappings":"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","file":"static/js/0.acfe7d57.chunk.js","sourcesContent":["import * as React from 'react';\nimport { useState } from 'react';\nimport produce from 'immer';\nwindow.produce = produce;\nexport default function TestImmer() {\n  const baseState = [\n    {\n      todo: 'Learn typescript',\n      done: true,\n    },\n    {\n      todo: 'Try immer',\n      done: false,\n    },\n  ];\n  const [todos, setTodos] = useState(baseState);\n\n  const onBtnClick = (value: string) => {\n    setTodos(\n      produce((draft) => {\n        draft.push({\n          todo: value,\n        });\n      }),\n    );\n  };\n  return (\n    <div>\n      <ul>\n        {todos.map((item, index) => (\n          <li key={index}>{item.todo}</li>\n        ))}\n      </ul>\n      <button onClick={() => onBtnClick('add new todo!')}>添加元素</button>\n    </div>\n  );\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/demo/immer/TestImmer.tsx","var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  if (!proto || proto === Object.prototype) { return true; }\n  return !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) { cb(i, value[i], value); }\n  } else {\n    ownKeys(value).forEach(function (key) { return cb(key, value[key], value); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\n// but share them all instead\n\nvar descriptors = {};\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) { markChanged(state); }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n    willFinalize: willFinalize,\n    createProxy: createProxy\n});\n\nfunction willFinalize$1() {}\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\nvar objectTraps = {\n  get: get$1,\n\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) { return state; }\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createProxy$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n    if (isUnchanged) { return true; }\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  }\n\n  if (state.copy) { delete state.copy[prop]; }\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n\n  return desc;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) { markChanged$1(state.parent); }\n  }\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n    willFinalize: willFinalize$1,\n    createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var useRemove = end != base.length;\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n\n    if (useRemove) {\n      inversePatches.push({\n        op: \"remove\",\n        path: path$1\n      });\n    }\n  } // One \"replace\" patch reverses all non-splicing \"add\" patches.\n\n\n  if (!useRemove) {\n    inversePatches.push({\n      op: \"replace\",\n      path: basePath.concat([\"length\"]),\n      value: base.length\n    });\n  }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nfunction applyPatches(draft, patches) {\n  for (var i = 0; i < patches.length; i++) {\n    var patch = patches[i];\n    var path = patch.path;\n\n    if (path.length === 0 && patch.op === \"replace\") {\n      draft = patch.value;\n    } else {\n      var base = draft;\n\n      for (var i$1 = 0; i$1 < path.length - 1; i$1++) {\n        base = base[path[i$1]];\n        if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n      }\n\n      var key = path[path.length - 1];\n\n      switch (patch.op) {\n        case \"replace\":\n          base[key] = patch.value;\n          break;\n\n        case \"add\":\n          if (Array.isArray(base)) {\n            // TODO: support \"foo/-\" paths for appending to an array\n            base.splice(key, 0, patch.value);\n          } else {\n            base[key] = patch.value;\n          }\n\n          break;\n\n        case \"remove\":\n          if (Array.isArray(base)) {\n            base.splice(key, 1);\n          } else {\n            delete base[key];\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unsupported patch operation: \" + patch.op);\n      }\n    }\n  }\n\n  return draft;\n}\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === undefined) { return base; }\n    return result !== NOTHING ? result : undefined;\n  }\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // Mutate the base state when a draft is passed.\n  if (isDraft(base)) {\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n\n        for (var prop in assigned) {\n          if (!assigned[prop]) { this.onDelete(state, prop); }\n        }\n      } else {\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === state.base[prop]) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n        }\n\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/immer/dist/immer.module.js\n// module id = 1055\n// module chunks = 0"],"sourceRoot":""}